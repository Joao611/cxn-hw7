---
title: "Homework 7"
author: "Alicja Dutkiewicz, Irina Gurewitsch, Jo√£o Esteves"
date: "02/11/2019"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(igraph)
library(purrr)
library(data.table)
library(R.utils)
```

## Exercise 7.1

#### (1)

```{r}
# Safer version of sample, fixes results for length 1
resample <- function(x, ...) x[sample.int(length(x), ...)]

genConfModel <- function(degs) {
  edges <- list()
  
  repeat {
    # Find unconnected stubs
    non_zero_inds <- which(degs > 0)
    if (length(non_zero_inds) < 2 & length(which(degs >= 2)) == 0) {
      break
    }
  
    # Randomly pick a stub
    stub1_ind <- resample(non_zero_inds, 1)
    degs[stub1_ind] <- degs[stub1_ind] - 1
  
    # Randomly pick a stub to connect the previous one to
    non_zero_inds <- which(degs > 0)
    stub2_ind <- resample(non_zero_inds, 1)
    degs[stub2_ind] <- degs[stub2_ind] - 1
    
    edges <- append(edges, list(list(stub1_ind, stub2_ind)))
  }
  
  links <- data.frame(t(sapply(edges, c)))
  
  return (links)
}
```

#### (2)

TODO

#### (3)

```{r}
degs1 <- c(2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2)
degs2 <- c(7, 4, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1)
```

| k<sub>1</sub> self-loops | k<sub>2</sub> self-loops | k<sub>1</sub> repeated edges | k<sub>2</sub> repeated edges |
|---------------|---------------|-------------------|-------------------|
| 4             | 3             | 0                 | 3                 |
| 1             | 3             | 4                 | 3                 |
| 1             | 2             | 0                 | 0                 |
| 1             | 1             | 0                 | 3                 |
| 1             | 2             | 2                 | 3                 |
| 0             | 3             | 0                 | 2                 |
| 0             | 1             | 2                 | 3                 |
| 1             | 3             | 4                 | 2                 |
| 0             | 4             | 4                 | 4                 |
| 0             | 2             | 2                 | 2                 |
| 1             | 2             | 0                 | 4                 |
| 0             | 1             | 0                 | 2                 |
| 0             | 3             | 0                 | 2                 |
| 1             | 3             | 4                 | 3                 |
| 1             | 3             | 0                 | 2                 |
| 2             | 2             | 0                 | 2                 |
| 1             | 5             | 0                 | 3                 |
| 2             | 2             | 0                 | 2                 |
| 0             | 4             | 2                 | 3                 |
| 1             | 2             | 0                 | 2                 |
| 0             | 3             | 0                 | 2                 |
| 1             | 1             | 6                 | 2                 |
| 2             | 1             | 0                 | 2                 |
| 1             | 4             | 0                 | 3                 |
| 0             | 2             | 0                 | 4                 |
| 1             | 3             | 0                 | 4                 |
| 0             | 2             | 0                 | 4                 |
| 1             | 2             | 4                 | 4                 |
| 1             | 3             | 0                 | 2                 |
| 0             | 3             | 0                 | 5                 |

The average number of self-loops in k1 is 0.83 while for k2 it's 2.5. The average number of repeated edges in k1 is 1.13 while for k2 it's 2.73.

## Exercise 7.2

#### (4)

Below, the function *genRepConfModel()* generates a graph from a given degree sequence via the Repeated Configuration Model.

```{r eval=FALSE}
degs1 <- c(2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2)
degs2 <- c(7, 4, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1)

# Safer version of sample, fixes results for length 1
resample <- function(x, ...) x[sample.int(length(x), ...)]

genRepConfModel <- function(degs) {
  edges <- list()
  
  repeat {
    # Find unconnected stubs
    non_zero_inds <- which(degs > 0)
    if (length(non_zero_inds) < 2 & length(which(degs >= 2)) == 0) {
      break
    }
  
    # Randomly pick a stub
    stub1_ind <- resample(non_zero_inds, 1)
    degs[stub1_ind] <- degs[stub1_ind] - 1
  
    # Randomly pick a stub to connect the previous one to
    non_zero_inds <- which(degs > 0)
    stub2_ind <- resample(non_zero_inds, 1)
    degs[stub2_ind] <- degs[stub2_ind] - 1
    
    # These conditional stops are the only differences from exercise 1.1
    if (stub1_ind == stub2_ind) {
      stop('Self-loop detected')
    }
    if (list(list(stub1_ind, stub2_ind)) %in% edges | list(list(stub2_ind, stub1_ind)) %in% edges) {
      stop('Repeated edge detected')
    }
    
    edges <- append(edges, list(list(stub1_ind, stub2_ind)))
  }
  
  links <- data.frame(t(sapply(edges, c)))
  
  return (links)
}

drawNewRepCM <- function(degs) {
  success <- FALSE
  i <- 0
  while (!success) {
    SUCCESS <- FALSE
    i <- i + 1
    printf('Generating graph: attempt %d\n', i)
    links <- tryCatch({
      genRepConfModel(degs)
    }, error = function(msg) {
      message('Restarting program. Reason:')
      message(msg)
      message('\n')
      return (NA)
    })
    if (!is.na(links)) {
      success <- TRUE
    }
  }
  network <- graph_from_data_frame(d=links, directed=FALSE)
  plot(network)
  return (i)
}

drawNewRepCM(degs1)
```

The code below generates 30 graphs via the function above with the goal of measuring the necessary amount of restarts each time.

```{r eval=FALSE}
restarts <- as.integer(list())
for (i in 1:30) {
  # restarts = attempts - 1
  restarts <- append(restarts, drawNewRepCM(degs1) - 1)
}
printf('Restarts: ')
for (r in restarts) {
  printf('%d ', r)
}
printf('Average restarts: %f\n', mean(restarts))
```

The results were that the average number of restarts required for k<sub>1</sub> were 2.133333 and for k<sub>2</sub> were 669.300. In addition, it was observed that the majority of these restarts were due to self-loops.
Generalizing this example, it means that degree distributions including elements with higher degrees tend to fail more. My explanation for this is that, as the vertices with smaller degrees get picked and crossed out the list, fewer vertices (with high degrees) remain and thus it's more likely they'll connect with themselves. In addition, having vertices with high degrees means they'll take longer to be picked for all the edges they can have, so they have more chances to repeat connections.

## Exercise 7.3

#### (5)

avgClusterCoef -> function(edges) {
  
}

#### (6)



## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
# plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
